---
title: Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法
publish_date: 2023-04-17
---

注视一个物品半分钟再开始读书

---
### 第1条：了解 Objective-C 语言的起源

Objective-C 语言由 Smalltalk 演化而来，后者是消息型语言的鼻祖。

Objective-C 为 C 语言添加了面向对象的特性，是 C 的超集。C 语言中所有功能在编写 Objective-C 代码时依然适用。

#### 一、OC语言使用动态绑定的“消息结构”（messaging structure）而非“函数调用”（function calling）。

关键区别在于：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。

如果调用的函数是多态的，那么在运行时就要按照 “虚方法表”（动态派发/运行时方法绑定），来查出到底应该执行哪个函数实现。

而采用消息结构的语言，不论是否多态，总是在运行时才会去查我所要执行的方法。实际上，编译器甚至不关心按收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做“动态绑定”(dynamic binding)，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。

#### 二、运行期组件

Objective-C 的重要工作都由 “运行期组件”（runtime component) 而非编译器来完成。使用 Objective-C 的面向对象特性所需的全部数据结构及函数都在运行期组件里面。

举例来说，运行期组件中含有全部内存管理方法。运行期组件本质上就是一种与开发者所编代码相链接的“动态库”（dynamic library），其代码能把开发者编写的所有程序粘合起来。这样的话，只需更新运行期组件，即可提升应用程序性能。而那种许多工作都在“编译期” (compile time) 完成的语言，若想获得类似的性能提升，则要重新编译应用程序代码。

#### 三、内存 & 指针

```
NSString *someString = @"The string";

// someString 变量指向分配在堆里的某块内存，其中含有一个 NSString 对象（实例）

NSString *anotherString = someString;

// 不会拷贝对象，只会拷贝指针，浅拷贝。
```

声明了一个 someString 变量，其类型是 NSString* ，也就是说，此变量是指向 NSString 的指针，也就是在堆中的 @"The string"。所有 Objective-C 语言的对象都必须这样声明，因为对象所占内存总是分配在“堆空间”（heap space）中，指针存储在栈中，每个指针占用4字节（32位架构），指针所在的内存里的值就是 NSString 实例的内存地址。

![](/books/栈和堆.png)

分配在堆中的内存必须直接管理，不需要用 malloc 及 free 来分配或释放对象所占内存，Objective-C 运行期环境把这部分工作抽象为一套内存管理架构，名叫“引用计数”。而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。

在 Objective-C 代码中，有时会遇到定义里不含 * 的变量，它们可能会使用“栈空间”，这些变量所保存的不是 Objective-C对象。比如 CoreGraphics 框架中的 CGRect

CGRect 是C结构体，其定义是：
```
    struct CGRect {
        CGPoint origin;
        CGSize size;
    };
    typedef struct CGRect CGRect;
```

整个系统框架都在使用这种结构体，因为如果改用 Objective-C 对象来做的话，性能会受影响。与创建结构体相比，创建对象还需要额外开销，例如分配及释放堆内存等。

---

### 第2条：在类的头文件中尽量少引入其他头文件

#### 向前声明

当声明文件**不需要知道被引用某个类的实现细节**时则在实现文件中使用@class，若在实现文件中使用到了这个类的接口细节，则在实现文件使用#import

```
解释：@class不会拷贝任何内容，只是告诉编译器这是一个类。
作用：减少编译时间；解决两个类互相运用问题。
```

当类继承自某个超类时，无法使用向前声明，必须#import引用定义那个超类的头文件，协议也是。

---

### 
